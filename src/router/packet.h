#ifndef PUT_RADIO_PACKET_H
#define PUT_RADIO_PACKET_H

#include <glog/logging.h>

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string>
#include <vector>
#include <deque>

#include "../radio.h"

#pragma pack(push)
#pragma pack(1)

namespace PUT {
  namespace CS {
    namespace XbeeRouting {

      /**
       * Single ACK entry definition.
       *
       * RemoteParameters describe status of edge used in transmission
       * packet to next hop. If packet was retransmittied multiple times
       * RemoteParameters contains arithmetic sum of every parameter.
       *
       * RemoteParameters contains parameters only applicable to given
       * single packet transmission (however the same packet may be
       * transmitted multiple times).
       *
       * @see Dispatcher::scan()
       */
      struct RemoteParameters {
        /**
         * Address of destination point of given edge.
         */
        Address hop = 0;

        /**
         * Delay in miliseconds.
         *
         * Delay is measured after sending Xbee Frame until
         * StatusFrame for given ID is received. So delay contains
         * only delay on single edge (not whole path).
         *
         * If packet is multiple times retransmittied, delay would never
         * overflow, it would stop at UINT16_MAX, that is 65536ms.
         */
        uint16_t delay = 0;

        /**
         * Number of undelivered packets.
         *
         * @see StatusFrame::status
         */
        uint8_t errors = 0;

        /**
         * Number of packet retries
         *
         * @see StatusFrame::retries
         */
        uint8_t retries = 0;
      };

      /**
       * Packet is the data type which is exchanged on Network level.
       * Packet is encapsulated into Xbee Frame.
       */
      struct Packet {
        //! Packet type
        enum class Type : uint8_t {
          //! Internal packet - provides direct access to Frame
          Internal = 0x00,
          //! Data packet - simple data
          Data = 0x01,
          //! Longer data
          // Jumbo = 0x02,
          //! Data ACK
          Ack = 0x03,

          //! Node broadcast packet
          NodeBroadcast = 0xFF - 0x01,
          //! Route drop
          EdgeDrop = 0xFF - 0x02,
          //! Drop every routing data
          // Reset = 0xFF - 0x03,
          //! Got graph
          Graph = 0xFF - 0x04
        } type;

        //! Packet source address
        Address source;
        //! Packet destination address
        Address destination;
        //! Ack origin (source address of coresponding packet to ack)
        Address origin;

        //! Data length - describes data count in Packet::data union
        uint8_t length;

        /**
         * Port number used when Packet::Type::Data.
         *
         * "Ports" are used to differentiate different queus when using Redis.
         *
         * @see PUT::XbeeRouting::Driver
         */
        uint8_t port = 0;

        //! Packet content
        union {
          //! Simple binary data if Type::Data
          uint8_t* content;

          //! Frame if Type::Internal
          Frame* frame;
          //! Node address if Type::NodeBroadcast
          Address address;
          //! Edge if Type::EdgeDrop
          Edge edge;
          //! Array of edges if Type::Graph
          Edge* edges;

          //! Edge parameters if Type::Ack
          RemoteParameters* parameters;
        } data;

        /**
         * MAC address of packet sender. Applicable only if Packet is received from the Xbee network.
         *
         * @see Packet::from_frame()
         * @see Frame
         * @see Router::receive()
         */
        uint64_t mac;

        /**
         * Constant packet ID.
         *
         * If packet_id is equal to zero, it is generated by Dispatcher
         * on the first node (source node). Otherwise frame_id is constant
         * during whole delivery process.
         *
         * Packet::packet_id needn't to equal Metadata::frame_id. Usually on
         * the first node they are the same, however on every other node,
         * Metadata::frame_id is generated for Xbee frame, while Packet::packet_id
         * remains constant.
         *
         * Together with Packet::source and Packet::destination, packet_id, creates
         * Packet::id(), which is unique in whole network during one state.
         *
         * @see Metadata::frame_id
         * @see Dispatcher::deliver()
         * @see Dispatcher::watch()
         * @see Packet::id()
         */
        uint8_t packet_id = 0;

        /**
         * Ack delivery status.
         *
         * If status is equal to 0x00, the coresponding packet was delivered to
         * destination node successfully.
         *
         * Otherwise status is an address of last node which got StatusFrame
         * with error or timeout.
         */
        Address status = 0;

        /**
         * Path containing every node between source and self (ideally destination),
         * which was visited.
         */
        Path visited;

        /**
         * Get unique ID of packet.
         *
         * ID of the packet is unique across whole network until packet
         * ACK is delivered to source. It is important to note that
         * Packet::id() of the Packet::Type::Data and corresponding Packet::Type::Ack
         * is the same!
         *
         * ID is created of Packet::destination, Packet::source and Packet::frame_id
         * in form of zDSF, where z is not used byte.
         *
         * @see Packet::frame_id
         */
        PacketId id() const;

        /**
         * Create internal packet
         */
        Packet() : type(Type::Internal) { };

        /**
         * Create packet of given type
         *
         * @param t Packet Type
         */
        Packet(Type t) : type(t) { };

        /**
         * Create Packet::Type::Data with simple string data.
         *
         * @param s String data (no nulls here!)
         */
        Packet(std::string s) {
          length = s.size();
          data.content = (uint8_t*)malloc(length * sizeof(uint8_t));
          strcpy((char*)data.content, s.c_str());
          type = Type::Data;
        };

        /**
         * Create Packet::Type::NodeBroadcast with address.
         *
         * @param a Node address to broadcast
         */
        Packet(Address a) {
          data.address = a;
          type = Type::NodeBroadcast;
        };

        /**
         * Create Packet::Type::EdgeDrop with edge.
         *
         * @param a Source
         * @param b Destination
         */
        Packet(Address a, Address b) {
          data.edge[0] = a;
          data.edge[1] = b;
          type = Type::EdgeDrop;
        };

        /**
         * Create Packet::Type::Ack from source for given packet with given status.
         *
         * @param p Packet for which ack is created
         * @param src Address of node from which ack will be send
         * @param stat Status for ack
         */
        Packet(Packet* p, Address src, Address stat);

        /**
         * Creates Packet from Frame.
         *
         * Every field in Packet is unserialized, depending on Packet::Type.
         * Packet::length becomes length of Packet::data elements.
         *
         * @param frame Frame in which Packet is encapsulated
         * @return Packet type
         */
        Type from_frame(Frame* frame);

        /**
         * Encapsulates Packet into Frame.
         *
         * Every field in Packet is serialized, depending on Packet::Type.
         * Created frame is of Frame::Type::Transmit and it is has its
         * length set to proper number, depending on variable data in Packet.
         *
         * Frame is need to have its destination address and id filled.
         *
         * @return Frame (ready to send)
         */
        Frame* to_frame();

        /**
         * Encapsulates Packet into Frame and fills frame's fields with given values.
         *
         * Every field in Packet is serialized, depending on Packet::Type.
         * Created frame is of Frame::Type::Transmit and it is has its
         * length set to proper number, depending on variable data in Packet.
         *
         * Frame is need to have its destination address and id filled.
         *
         * @return Frame (ready to send)
         */
        Frame* to_frame(uint8_t id, uint64_t mac, uint16_t network, uint8_t radius = 0x00, uint8_t options = 0x00);

        /**
         * Destroys packet and every associated data.
         *
         * Does clean memory if Type::Data, Type::Jumbo, Type::Ack or Type::Internal.
         */
        ~Packet();
      };
    }
  }
}
#pragma pack(pop)

#endif
